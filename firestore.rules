rules_version='2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================================
    // HELPER FUNCTIONS
    // ============================================================================

    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Check if the authenticated user matches the userId
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Check if user is a player in the room
    function isPlayerInRoom(roomData) {
      return isAuthenticated() && request.auth.uid in roomData.players;
    }

    // Check if it's the user's turn in the room
    function isPlayerTurn(roomData) {
      return isAuthenticated() &&
             roomData.order_players[roomData.turn] == request.auth.uid;
    }

    // Validate room status transitions
    function isValidStatusTransition(oldStatus, newStatus) {
      return (oldStatus == 'waiting' && newStatus == 'intro') ||
             (oldStatus == 'intro' && newStatus == 'playing') ||
             (oldStatus == 'playing' && newStatus == 'finished') ||
             (oldStatus == newStatus); // Allow same status (for other field updates)
    }

    // Check if incoming room data has valid structure
    function hasValidRoomStructure(data) {
      return data.keys().hasAll(['players', 'status', 'createdAt', 'finishedAt',
                                  'lastUpdate', 'order_players', 'turn',
                                  'memory_deck', 'current_card']);
    }

    // Check if status is valid
    function hasValidStatus(status) {
      return status in ['waiting', 'intro', 'playing', 'finished'];
    }

    // Validate player data structure
    function hasValidPlayerStructure(player) {
      return player.keys().hasAll(['integrity', 'items']) &&
             player.integrity is number &&
             player.items is list;
    }

    // Check if only allowed fields are being modified during game
    function onlyAllowedFieldsModified(allowedFields) {
      return request.resource.data.diff(resource.data).affectedKeys()
             .hasOnly(allowedFields);
    }

    // ============================================================================
    // USERS COLLECTION
    // ============================================================================

    match /users/{userId} {
      // Users can read their own document OR any user document
      // (needed to display player names in game rooms)
      allow read: if isAuthenticated();

      // Users can create their own document during registration
      allow create: if isOwner(userId) &&
                       request.resource.data.keys().hasAll(['email', 'name', 'current_room']) &&
                       request.resource.data.email is string &&
                       request.resource.data.name is string &&
                       (request.resource.data.current_room == null ||
                        request.resource.data.current_room is string);

      // Users can update their own document (mainly current_room field)
      allow update: if isOwner(userId) &&
                       // Prevent changing email after creation
                       request.resource.data.email == resource.data.email &&
                       // Name can be changed
                       request.resource.data.name is string &&
                       // current_room can be updated
                       (request.resource.data.current_room == null ||
                        request.resource.data.current_room is string);

      // Users cannot delete their own document (must be done server-side)
      allow delete: if false;
    }

    // ============================================================================
    // ROOMS COLLECTION
    // ============================================================================

    match /rooms/{roomId} {

      // Anyone authenticated can read a room (to check if it exists/join)
      // In production, you might want to restrict this to only players
      allow read: if isAuthenticated();

      // Creating a new room
      allow create: if isAuthenticated() &&
                       hasValidRoomStructure(request.resource.data) &&
                       hasValidStatus(request.resource.data.status) &&
                       // Must start in waiting status
                       request.resource.data.status == 'waiting' &&
                       // Creator must be the only player initially
                       request.resource.data.players.size() == 1 &&
                       request.auth.uid in request.resource.data.players &&
                       hasValidPlayerStructure(request.resource.data.players[request.auth.uid]) &&
                       // Creator must be in order_players
                       request.resource.data.order_players.size() == 1 &&
                       request.resource.data.order_players[0] == request.auth.uid &&
                       // Turn must be 0
                       request.resource.data.turn == 0 &&
                       // Memory deck must be empty initially
                       request.resource.data.memory_deck.size() == 0 &&
                       // No current card initially
                       request.resource.data.current_card == null &&
                       // Timestamps must be set
                       request.resource.data.createdAt is timestamp &&
                       request.resource.data.finishedAt == null &&
                       request.resource.data.lastUpdate is timestamp;

      // Updating a room (game moves, player joining, etc.)
      allow update: if isAuthenticated() &&
                       // Either already a player OR joining the room
                       (isPlayerInRoom(resource.data) ||
                        request.auth.uid in request.resource.data.players) &&
                       hasValidRoomStructure(request.resource.data) &&
                       hasValidStatus(request.resource.data.status) &&
                       // Validate status transition
                       isValidStatusTransition(resource.data.status,
                                             request.resource.data.status) &&
                       // Timestamps must remain or be updated correctly
                       request.resource.data.createdAt == resource.data.createdAt &&
                       request.resource.data.lastUpdate is timestamp &&
                       // Players count cannot exceed 2
                       request.resource.data.players.size() <= 2 &&
                       // Existing players cannot be removed (except voluntarily)
                       (request.resource.data.players.keys().hasAll(resource.data.players.keys()) ||
                        // Or it's the player themselves leaving
                        !(request.auth.uid in request.resource.data.players)) &&
                       // Validate game move logic
                       validateGameMove(resource.data, request.resource.data);

      // Allow deletion only for empty waiting rooms
      // Players can delete a room if:
      // 1. They are authenticated
      // 2. They are/were a player in the room
      // 3. The room is in 'waiting' status
      // 4. The room will be empty after they leave (they are the last/only player)
      allow delete: if isAuthenticated() &&
                       resource.data.status == 'waiting' &&
                       request.auth.uid in resource.data.players &&
                       resource.data.players.size() <= 1;

      // ============================================================================
      // GAME MOVE VALIDATION
      // ============================================================================

      // Complex function to validate game moves
      function validateGameMove(oldData, newData) {
        let statusChanged = oldData.status != newData.status;
        let isWaiting = oldData.status == 'waiting';
        let isPlaying = oldData.status == 'playing';
        let isCurrentTurn = isPlayerTurn(oldData);

        return (
          // Scenario 1: Player joining (status is still 'waiting')
          (isWaiting &&
           newData.status == 'waiting' &&
           newData.players.size() == oldData.players.size() + 1 &&
           onlyAllowedFieldsModified(['players', 'order_players', 'lastUpdate'])) ||

          // Scenario 2: Starting the game (waiting -> intro or intro -> playing)
          (statusChanged &&
           (oldData.status == 'waiting' || oldData.status == 'intro') &&
           newData.players.size() == 2 && // Must have 2 players to start
           onlyAllowedFieldsModified(['status', 'memory_deck', 'lastUpdate'])) ||

          // Scenario 3: Player making a move during their turn
          (isPlaying &&
           isCurrentTurn &&
           validateTurnMove(oldData, newData)) ||

          // Scenario 4: Game ending (playing -> finished)
          (isPlaying &&
           newData.status == 'finished' &&
           newData.finishedAt is timestamp &&
           onlyAllowedFieldsModified(['status', 'finishedAt', 'lastUpdate'])) ||

          // Scenario 5: Player leaving room
          (newData.players.size() == oldData.players.size() - 1 &&
           !(request.auth.uid in newData.players) &&
           onlyAllowedFieldsModified(['players', 'order_players', 'lastUpdate']))
        );
      }

      // Validate a single turn move
      function validateTurnMove(oldData, newData) {
        let currentPlayerId = oldData.order_players[oldData.turn];
        let opponentId = oldData.order_players[(oldData.turn + 1) % 2];

        return (
          // Turn must increment or wrap around
          (newData.turn == (oldData.turn + 1) % 2) &&
          // Can only modify specific fields
          onlyAllowedFieldsModified(['turn', 'current_card', 'memory_deck',
                                     'players', 'lastUpdate']) &&
          // Player can only modify their own or opponent's integrity (based on game logic)
          validateIntegrityChanges(oldData, newData, currentPlayerId, opponentId) &&
          // Memory deck size must decrease by 1 (card drawn)
          (newData.memory_deck.size() == oldData.memory_deck.size() - 1 ||
           newData.memory_deck.size() == oldData.memory_deck.size()) // Allow same size if card added back
        );
      }

      // Validate that integrity changes are legitimate
      function validateIntegrityChanges(oldData, newData, currentPlayerId, opponentId) {
        let currentPlayerOldIntegrity = oldData.players[currentPlayerId].integrity;
        let currentPlayerNewIntegrity = newData.players[currentPlayerId].integrity;
        let opponentOldIntegrity = oldData.players[opponentId].integrity;
        let opponentNewIntegrity = newData.players[opponentId].integrity;

        return (
          // Current player's integrity can only change within reasonable bounds (-3 to +3 per turn)
          (currentPlayerNewIntegrity >= currentPlayerOldIntegrity - 3 &&
           currentPlayerNewIntegrity <= currentPlayerOldIntegrity + 3) &&
          // Opponent's integrity can only change within reasonable bounds
          (opponentNewIntegrity >= opponentOldIntegrity - 3 &&
           opponentNewIntegrity <= opponentOldIntegrity + 3) &&
          // At least one player's integrity must change (unless it's a neutral card)
          (currentPlayerNewIntegrity != currentPlayerOldIntegrity ||
           opponentNewIntegrity != opponentOldIntegrity ||
           true) // Allow no change for neutral cards
        );
      }
    }

    // ============================================================================
    // DECKS COLLECTION (Read-only predefined data)
    // ============================================================================

    match /decks/{deckId} {
      // Anyone authenticated can read decks
      allow read: if isAuthenticated();

      // Decks cannot be created, updated, or deleted by clients
      // These should be managed server-side or through admin SDK
      allow write: if false;
    }
  }
}
